# Skeleton Key
Skeleton Key is an imaginary basal key "type" used across all libraries maintained by Breach Dogs. These keys may not be generated in consistent ways, and are used across almost every ECS-like component we have made. Ultimately, it was the emergence of the need for an up-projection into the concept of an actor for the purposes of assigning abilities and attributes to non-actors that drove the creation of ObjectKey. Once objecttype existed, it became necessary to provide a way to tell which keys belonged to which keyspace at runtime. Unfortunately, generating guids in a multithreaded multimachine multiOS way is actually quite hard. Instead, we have the Skeleton Key.

## Why Is This A Plugin?
While it's unfortunate that this ended up in a plugin, because that's sort of funny for one file, we need versioning, loading, and dependency assurances. It also means that some of our simpler types like keys and params may move into the skeleton key plugin, which would honestly be nice for making the individual plug-ins less weird. In particular, we currently have BristleTime and ArtilleryTime, but it'd be nice to have just StepTime. Without a top level types lib, that's not really elegantly doable in UE+C++ without esoterica that I don't want to employ. Finally, I could see this being expanded to cover certain monomorphizing constants that you really want to be able to adjust at a per-game level and span across plugins, but may not wish to have be configurable. These are quite quite rare, but do exist.

## Mechanism
Skeleton keys contain an 7 bit typing pattern, with all 0s being reserved for "not an object key." This can be used for runtime type inference without reflecting in constant time and one branch, allowing any key for a type of object to be transparently used as an objectkey that will route correctly through the ECS. This is not a very elegant solution, as it permits us only around 120 types of ECS Keys that are considered Object-Like after some reserved patterns, but if we exhaust that space, we probably deserve what happens next. The base input into a skeleton key must be a MSB\LSB neutral hash function with as close to a pure random distribution as possible. As a result, LSH cannot be used for skeleton keys, because we transparently mask the key prefix into the MSB
